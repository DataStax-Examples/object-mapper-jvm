import sbt.Keys.packageBin

ThisBuild / scalaVersion := "2.13.2"
ThisBuild / version := "0.1.0-SNAPSHOT"
ThisBuild / organization := "com.datastax"
ThisBuild / organizationName := "datastax"

// Also fetch dependencies from the local Maven repo.
// Not mandatory, but this is convenient to test against driver snapshots.
ThisBuild / resolvers += "Local Maven Repository" at "file://" + Path.userHome.absolutePath + "/.m2/repository"

lazy val processMapperAnnotations = taskKey[Unit]("Process Object Mapper annotations in compiled Scala classes")
lazy val compileMapperGeneratedSources = taskKey[Unit]("Compile the sources that were generated by the Object Mapper")

def runCommand(command: String, message: => String, log: Logger) {
  import scala.sys.process._

  val result = command !

  if (result != 0) {
    log.error(message)
    sys.error("Failed running command: " + command)
  }
}

lazy val model = project
  .settings(
    libraryDependencies ++= Seq(
      Dependencies.javaDriverMapperRuntime,
      Dependencies.bcrypt,
      // TODO it would be cleaner to pass this separately to -processorpath when invoking javac, but I couldn't figure out how to do it with sbt
      Dependencies.javaDriverMapperProcessor % "provided"
    ),

    processMapperAnnotations := {
      val log = streams.value.log

      log.info("Processing Object Mapper annotations in compiled Scala classes...")

      val classpath = ((products in Compile).value ++ (dependencyClasspath in Compile).value.files) mkString ":"
      val sourceDirectory = (classDirectory in Compile).value
      val classesToProcess = (sourceDirectory ** "*.class")
        .getPaths()
        .map(_.stripPrefix(sourceDirectory.getAbsolutePath + "/").stripSuffix(".class").replaceAll("/", "."))
        .mkString(" ")
      val destinationDirectory = (Compile / sourceManaged).value / "mapper"
      destinationDirectory.mkdirs()

      val processor = "com.datastax.oss.driver.internal.mapper.processor.MapperProcessor"

      val command =
        s"""javac
           | -classpath $classpath
           | -proc:only -processor $processor
           | -d $destinationDirectory
           | $classesToProcess""".stripMargin
      runCommand(command, "Failed to run Object Mapper processor", log)

      log.info("Done processing Object Mapper annotations in compiled Scala classes")
    },

    compileMapperGeneratedSources := {
      val log = streams.value.log

      log.info("Compiling Object Mapper generated sources...")

      val classpath = ((products in Compile).value ++ (dependencyClasspath in Compile).value.files) mkString ":"
      val sourceDirectory = (Compile / sourceManaged).value / "mapper"
      val javaSources = (sourceDirectory ** "*.java").getPaths().mkString(" ")

      // TODO there's probably a better way than invoking javac manually
      val command =
        s"""javac
           | -classpath $classpath
           | -d ${(classDirectory in Compile).value}
           | $javaSources""".stripMargin
      runCommand(command, "Failed to compile mapper-generated sources", log)

      log.info("Done compiling Object Mapper generated sources")
    },

    compileMapperGeneratedSources in Compile := (compileMapperGeneratedSources in Compile dependsOn (processMapperAnnotations in Compile)).value,

    packageBin in Compile := (packageBin in Compile dependsOn (compileMapperGeneratedSources in Compile)).value
  )

lazy val app = project.dependsOn(model)
  .settings(
    libraryDependencies += Dependencies.logback,
    compile in Compile := (compile in Compile  dependsOn (compileMapperGeneratedSources in Compile in model)).value,
    mainClass in Compile := Some("com.datastax.examples.MapperApp")
  )
